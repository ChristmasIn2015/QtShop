# 软件工程概述

软件工程是一门工程学科，涉及软件生产的各个方面，从最初的系统描述一直到投入使用后的系统维护，都属于其学科范畴。软件工程不仅涉及软件开发的技术过程，也涉及诸如软件项目管理以及对那些支持软件生产的工具、方法和理论的开发等活动。

- 软件工程之所以重要有两方面的原因1️⃣个人和社会越来越多地依赖先进的软件系统。这就需要我们能够既经济又快速地生产出可依赖和值得信赖的系统2️⃣从长远来看，运用软件工程方法和技术去开发软件系统比单纯为个人程序项目写程序更加便宜。对大多数类型的系统来说，绝大多数的钱都花费在软件投入使用后对软件的变更上。
- 我们通常使用⚠软件过程模型来进行其生产管理，并从中获取决策信息。软件过程模型是对软件开发过程的一种有用的抽象，下述是常见的三种软件过程模型：
  - 1️⃣瀑布式：将基本的开发活动划分为界限分明的独立过程，后续过程总是依赖之前的过程结果。
  - 2️⃣增量式：听取用户的使用意见和建议，将基本的开发活动交织在一起，通过一系列的版本（增量）发布来实现系统的开发。
  - 3️⃣复用式：通过集成大量可复用的组件到新系统中而非从头开发。
- [参考书籍](#参考书籍)

# 软件生产管理

## 敏捷开发（生产）过程

> 管理民用建筑生产过程时采用的大量前期设计并不适合软件工程。	

当前的业务都处于全球性、快速变化的环境中，新的软件要迅速地开发出来以抓住新的机遇。建立在传统需求描述，然后进行设计和实现，最终再进行测试的，完整计划上的软件生产不适应快速软件开发。当需求发生改变，或者是当需求出现问题时，系统设计和实现不得不返工和重新进行测试。其结果是，传统的瀑布模型或基于描述的软件生产总是拖延，最后软件交付的时间远远晚于最初的规定。最终对这种重量级过程模型的不满，引发了众多开发人员提出了基于⚠增量式开发的生产过程模型，并称之为敏捷开发，其包含：

- 极限编程（生产）过程
  - 1️⃣增量定义，一般一个增量为一个版本
  - 2️⃣为此增量选择用户故事情节、业务流程
  - 3️⃣将故事情节分解成开发任务
  - 4️⃣通过过程管理软件进行进度追踪
  - 5️⃣开发/集成/测试软件
  - 6️⃣发布增量
  - 7️⃣处理用户反馈
  - 8️⃣开始下一个增量
- Scrum（生产）过程
  - 1️⃣规划纲要
  - 2️⃣建立增量冲刺循环
  - 3️⃣总结项目

影响软件工程成功的因素有很多，最终个体与个体之间的实际互动才能真正决定工程的成功或者失败。但是，组织结构及其整体文化也会影响最终结果。我们应该尽量做到1️⃣让技能上互补的开发者相互合作，相互建立好的沟通。2️⃣设立轮岗的 Scrum 救火员。3️⃣充分信任管理层，并尽可能争取开发资源。对于英雄的需要以及由此而来的高压力，往往是由于资源不够充足。4️⃣不开发垃圾。5️⃣善用工具。6️⃣鼓励实践。7️⃣持续改变。

# 软件生产步骤

软件工程必须具有 4 种基本的⚠软件生产活动，这些活动可能是像使用 Java 和 C 这样的标准编程语言从头开始的一步步的软件开发，通常也会是通过扩展和修改现有的系统、或通过配置和集成商业现货软件或系统组件而获得。
- [需求工程](#需求工程)
- [软件设计与实现](#软件设计与实现)
- [软件有效性验证](#软件有效性验证)
- [软件进化](#软件进化)

## 1.需求工程

> 罗列你真正的需求，删除那些不必要的需求。写出实现需求的步骤，再删除不必要的步骤。继续重复上述两个步骤，看看这些步骤能不能加速，能不能自动化。—— Elon Musk

需求工程是理解和定义系统需要提供哪些服务，以及找出开发和运行中受到哪些约束。需求工程一般也包含产品设计，是软件开发过程中一个特别关键的阶段，这个阶段的错误将不可避免地带来系统设计和实现阶段的后续问题。需求工程目标是生产一个达成一致意见的需求文档/用户故事，定义能满足信息持有者需求的系统。需求工程有：

* 四个主要的阶段：1️⃣技术可行性研究2️⃣客户诉求导出和分析3️⃣需求文档化4️⃣需求有效性验证。在这个
* 两个层次表述，最终用户需要高层的需求描述（产品架构），而系统开发人员需要比较详细的系统描述（技术架构）。需求导出方案有以下两种：
  * 对于简单的软件，可以像典型的需求过程那样：首先收集需求，通过一些分析找出相关的业务实体，如用户、订单等；接着带着这些理解，尝试设计支撑业务实体间的业务流程，推导能够实现的GUI和数据表设计（通常是关系型）；然后组织GUI和服务端的交互（通常是RESTful）完成业务流程，如用户登录，创建订单等；最后一般能得文字型文档、以及许多技术模型图、产品泳道图。
  * 对于较为复杂的软件，可以采用⚠领域驱动设计 Domain-driven design ，它的核心是在软件中模拟如何在现实世界中解决问题，并把现实世界称为业务领域，它包含多个业务上下文，每个上下文都有最适合自己的架构。Domain Driven Design 的核心就是消化特定领域知识，并创建忠实反映它的软件模型。这其实是分而治之的一种思想体现，它帮助凯撒和拿破仑统治世界。(PS: 这种建模方式总是一说明就懂，一讨论就打架。)，最后和简单软件需求过程一样，能得文字型文档、以及许多技术模型图、产品泳道图。

- [返回首页](#软件工程概述)

## 2.软件设计与实现

> 每个人都在讨论，但没人知道怎么做。每个人都认为别人在做，结果每个人都认为这件事情值得做。

- 软件开发的实现阶段是把系统描述转换成一个可运行的系统的过程，它总是包含涉及和编程。这个过程描述了软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。设计者不可能一次就能完成一个完整的涉及，这是一个反复多次的过程。在设计过程中要不断添加设计要素和设计细节，并对先前的设计方案进行修正。软件设计因人而异，通常没有统一的模式。一些程序设计者从已经理解得很好的组件开始做起，然后再做不太熟悉的组件。其他人可能会采取相反的方案，把熟悉的组件留到最后，因为他们已经知道该如何开发这些组件。一些开发者喜欢先定义过程中要用到的数据，然后使用这些数据来驱动程序的开发。而另外一些人则是对数据现用现定义。设计过程一般包含：
  - [系统建模](#系统建模)
  - [结构设计](#结构设计)
  - [系统实现](#系统实现)

### 系统建模

一般在制作需求文档时，基本已经完成了简单的系统建模。我们主要通过系统建模来更好的理解⚠需求文档。系统建模就是建立系统抽象模型的过程，每一个模型表示一个系统不同的角度或者方面。其一般有1️⃣上下文模型：确定需求中较大颗粒度功能的数量和边界。2️⃣交互模型：有助于我们分析所提出的系统结构是否能实现需求文档所提及的功能及其可靠性。3️⃣结构模型：即系统体系结构设计，表示为组件构成的系统及组件之间的关系。4️⃣行为模型：描述系统运行时的动态行为。如数据输入，事件触发。

### 结构设计

> 软件架构中无时无刻地在表现组织结构。—— Melvin Conway(1967)

结构设计关心的是如何组织一个系统以及设计系统的整体结构，它的主要作用是识别系统的⚠主要模块以及它们之间的⚠关系。

* 什么是好的模块？我们需要好的⚠设计原则
  * 单一职责（Simple Responsibility）：模块要尽量简单，并专注于一个核心任务
  * 开闭原则（Open Close）：应当尽量保证模块对拓展开发，在后续使用中不可修改
  * 里氏代换（Liskov Substitution）：好的继承：如果继承后的子类能够替换基类工作，那么这就是一个好的子类
  * 接口分离（Interface Segregation）：好的接口：模块中尽量不应该存在无用的接口方法
  * 依赖反转（Dependency Inversion）：鼓励面向接口编程：细节应当依赖于抽象，抽象不应当依赖于细节

* 如何处理模块间复杂的依赖？我们需要实用的⚠设计模式
  * 控制反转：（Inversion of Control）通过配置将模块获取依赖这个过程，交给第三方生产工具。第三方生产工具通常称为IOC容器。
  * 服务定位：（Service Locator Pattern）所有需要的服务都会被注册到服务定位器中，应用从服务定位器中得到服务。但是服务定位器的服务注册使代码更加复杂，当依赖有错误时只能在运行时发现。

好的结构设计已经在不同的系统和环境中多次实践和测试过，常见的结构设计实践包含

* 着重低依赖的⚠容器，如 Java Web中基于控制反转设计的 Spring 容器，我们通过它来配置、创建对象，并管理他们从创建到销毁的整个生命周期；
* 着重职责分明的 ⚠三层架构：表现层、业务层、持久层；⚠领域驱动设计 Domain Driven Design 将传统三层架构的业务层拆解为应用层和领域层，其中应用层划分为很薄的一层服务，非核心的逻辑放到此层去实现，核心的业务逻辑表现下沉到领域层去实现，凝练为更为精确的业务规则集合，通过领域对象去阐述说明。
* 着重独立性的多层架构：表现层、应用层、领域层、基础设施层；✅应用层定义软件要完成的任务，并且指挥协调领域对象进行不同的操作。该层不包含业务领域知识；✅领域层包含一个领域模型，以及一组可能的领域服务；领域模型的终极目标是实现统一语言和表达业务所需要的操作，此时暴漏行为比起持有数据更有意义。✅领域服务通常处于某种原因无法放入任何领域模型中，它包含了一些逻辑上有关系并且操作多个领域实体的行为，同时领域服务也需要访问基础设施层执行持久行为。✅基础设施层是与使用具体技术有关的任何东西。如消息中间件、数据持久化、日志、业务追踪、Inversion of Control 容器等
* ⚠主从结构，它通常用于简单的分布式系统中，包含一个应用层和多个业务层，一般用于调度系统；
* ⚠面向服务的体系结构 Service Oriented Architecture，它着重强调服务治理，一般用于于分布式系统，它的工作流程是 ：
  1. Container 作为容器启动、加载、运行服务 Provider
  2. Provider 启动时，向 Registry 注册自己提供的服务
  3. Customer 启动时，向 Registry 订阅自己所需的服务
  4. Registry 推送服务提供者地址列表给 Customer
  5. Customer 从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用
  6. Customer 和 Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到 Monitor
* 着重GUI流程的⚠Model View Controller 结构，常用于终端应用中

### 系统实现

- 软件实现指开发出可执行的软件系统。对简单系统来说，软件设计和实现就是软件工程的全部，其他所有活动都融汇在这个过程中。但是对于大型系统，软件设计和实现只是一系列软件工程过程的一步骤。

[返回首页](#软件工程概述)

## 3.软件有效性验证

软件有效性验证是要看系统是否符合它的描述以及系统是否满足客户的预期。这个过程通常称为测试过程，其中的阶段包括1️⃣单元测试：由开发系统的人员对组成系统的组件进行测试。组件可能是简单的实体，如一个函数或者对象类。2️⃣系统测试：集成组件形成完整的系统。这个过程主要是关注无法预测的组件间交互和组件界面问题引发的错误。也关注系统是否满足了功能上和非功能上的需求，并测试系统的总体特性。3️⃣接收测试：这是系统在接受并运行之前进行的最后阶段测试。这个阶段不再使用模拟数据来测试系统，而是用客户提供的真实数据测试系统。统计学上表明一件事情，如果有可能，那么它一定会发生。在软件开发中，我们可以断言如果软件没经过测试，那么它一定会发生错误。

> 工程师都容易过度自信。但如果想要跑得快，就必须先要要跑的稳健。

[返回首页](#软件工程概述)

## 4.软件进化

软件进化是修改已存在的软件系统以适应用户新的需求的过程。变更是一个持续的过程，软件必须在变更过程中保持可用。软件进化一般包括以下工作：

* ⚠维护遗留代码：所有的软件在使用期间都需要维护遗留代码。即使做好了最好准备，也不管团队的努力如何，系统的设计都可能在某个时刻陷入困境，最终大片代码开始变得难以维护和进化。管理者面临和魔鬼的交易，要么更多地修补和变通遗留代码，要么根据审核的需求和新的架构进行一次彻底的重新设计。就采取的措施而言修补和重新开发的区别是极小的，但在心理层面上重新开发则是管理层在承认失败。我们都很难愿意接受失败。当我们的代码都处于高质量的状态时，日常工作几乎就是扩展和维护代码。这意味着使用设计原则设计好的结构，通过设计模式处理结构依赖，提升结构的维护性，掌握实用的设计实践是每个开发者都需要掌握的内容。但只要提及代码质量都会面临大量的生产力缺失以及成本控诉。生产力非常重要，但只关注生产力会导致更大成本，因为这会导致质量低下、难以维护的代码。无法修改的软件在变更需求后体现价值为零；但是目前无法工作的，但在未来可以持续修改的软件，会持续产生价值。下面是一些面向维护的建议：
  * 尽量在软件设计阶段保证结构的可读性、可测试性、可拓展性；
  * 建立可测试性的有效方法之一就是面向测试开发（Test Design Development）；
  * 当面对遗留代码时，就好像面对运动损伤（无法修改的模块），医生会建议你停止运动（停止开发工作），在受伤的地方进行隔离和救治（代码隔离），当感觉良好的时候就开始尝试走动，如果感觉不舒服就停止（反复测试，持续重构）；
* ⚠有效重构：好的软件必须确保自身可以有效重构。在敏捷开发中持续处理用户反馈正是软件可拓展的一个重要用途。
* ⚠业务拓展：从资源共享、系统开放、性能并发、可拓展性、容错性上来看，将大型机遗留系统进化为⚠分布式软件系统是一种很好的实践。其中用于协调多台计算机的软件，我们称之为⚠中间件。分布式中多台计算机的沟通，它一般分为两种
  * 1️⃣基于过程的沟通（Remote Procedure Call）：一台计算机请求并总是等待另一台计算机的服务
  * 2️⃣基于消息的沟通：一台计算机仅发送消息给另外一台计算机。
* ⚠性能拓展：当软件系统存在明显性能问题时，创建⚠服务集群进行均衡负载⚠精简业务并进行服务治理（SOA）都是很好的方案

[返回首页](#软件工程概述)

# 电商业务架构

## 1.需求工程-领域上下文划分

1. 运营中心
   1. 会员系统：登录/积分
   2. 货架（Content Manage System）系统
   3. 促销系统：优惠券/秒杀/团购
   4. 售后服务：退换货/投诉/建议
   5. 客户关系（Customer Relationship Management）：短信/邮件/回访
2. 交易中心
   1. 产品系统：品类/商品/定价/库存
   2. 采购系统：供应商/合同
   3. 仓储系统：分仓/出入库/分拣/盘点
   4. 导购系统：频道/专题/搜索
   5. 预定系统：常规售卖/拍卖/预售/购物车
   6. 订单系统
   7. 物流系统
   8. 渠道系统：分销商/商品/订单
3. 金融中心
   1. 支付：充值/提现/转账
   2. 财务：账户/账务/清算/发票
   3. 风控

# 参考书籍

-   《Microsoft .NET 企业级应用架构设计（第二版）》
-   《软件工程》Ian Sommerville
-   《产品设计思维》http://www.aoyii.com/ecm-pd-02.html

[返回首页](#软件工程概述)
