# 软件工程概述

- 软件工程是一门工程学科，涉及软件生产的各个方面，从最初的系统描述一直到投入使用后的系统维护，都属于其学科范畴。软件工程不仅涉及软件开发的技术过程，也涉及诸如软件项目管理以及对那些支持软件生产的工具、方法和理论的开发等活动。软件工程离不开工程人员，他们既拥有一定的理论、方法和工具，又能有选择地利用它们，即使在没有可用的理论和方法的情况下，也能够力求解决问题的方法。软件工程之所以重要有两方面的原因1️⃣个人和社会越来越多地依赖先进的软件系统。这就需要我们能够既经济又快速地生产出可依赖和值得信赖的系统2️⃣从长远来看，运用软件工程方法和技术去开发软件系统比单纯为个人程序项目写程序更加便宜。对大多数类型的系统来说，绝大多数的钱都花费在软件投入使用后对软件的变更上。

- 软件工程必须具有 4 种基本的<font color="red">**软件生产活动**</font>，这些活动可能是像使用 Java 和 C 这样的标准编程语言从头开始的一步步的软件开发，通常也会是通过扩展和修改现有的系统、或通过配置和集成商业现货软件或系统组件而获得。
  - [需求工程](#需求工程)
  - [软件设计与实现](#软件设计与实现)
  - [软件有效性验证](#软件有效性验证)
  - [软件进化](#软件进化)
  - [参考书籍](#参考书籍)

- 我们通常使用软件过程模型来执行<font color="red">**软件生产管理**</font>，并从中获取信息。软件过程模型是对软件开发过程的一种有用的抽象，下述是常见的三种软件过程模型：1️⃣瀑布式：将基本的开发活动划分为界限分明的独立过程，后续过程总是依赖之前的过程结果。2️⃣增量式：听取用户的使用意见和建议，将基本的开发活动交织在一起，通过一系列的版本（增量）发布来实现系统的开发。3️⃣复用式：通过集成大量可复用的组件到新系统中而非从头开发。当前的业务都处于全球性、快速变化的环境中，新的软件要迅速地开发出来以抓住新的机遇。建立在传统需求描述，然后进行设计和实现，最终再进行测试的，完整计划上的软件生产不适应快速软件开发。当需求发生改变，或者是当需求出现问题时，系统设计和实现不得不返工和重新进行测试。其结果是，传统的瀑布模型或基于描述的软件生产总是拖延，最后软件交付的时间远远晚于最初的规定。最终对这种重量级过程模型的不满，引发了众多开发人员提出了基于增量式开发概念的<font color="red">敏捷开发方法</font>。其中最流行的敏捷方法包含：
  - 极限编程：1️⃣增量（版本）定义2️⃣为此增量选择用户故事情节3️⃣将故事情节分解成任务4️⃣增量追踪5️⃣开发/集成/测试软件6️⃣发布增量7️⃣处理用户反馈8️⃣开始下一个增量
  - Scrum管理：1️⃣规划纲要2️⃣建立增量冲刺循环3️⃣总结项目

> 管理民用建筑生产过程时采用的大量前期设计并不适合软件工程。
>
> 个体和交互胜过过程和工具；编写软件胜过书写详尽的文档；用户合作胜过合同谈判；响应变更胜过遵循计划。 —— 敏捷宣言四大核心（2001）

* 影响软件工程成功的因素有很多，最终个体与个体之间的实际互动才能真正决定工程的成功或者失败。但是，组织结构及其整体文化也会影响最终结果。我们应该尽量做到1️⃣让技能上互补的开发者相互合作，相互建立好的沟通。2️⃣设立轮岗的 Scrum 救火员。3️⃣充分信任管理层，并尽可能争取开发资源。对于英雄的需要以及由此而来的高压力，往往是由于资源不够充足。4️⃣不开发垃圾。5️⃣善用工具。6️⃣鼓励实践。7️⃣持续改变。

# 需求工程

- 软件描述或需求工程是理解和定义系统需要提供哪些服务，以及找出开发和运行中收到哪些约束。需求工程是软件开发过程中一个特别关键的阶段，这个阶段的错误将不可避免地带来系统设计和实现阶段的后续问题。需求工程目标是生产一个达成一致意见的需求文档，定义能满足信息持有者需求的系统。通常文档中又两个层次表述。最终用户需要高层的需求描述，而系统开发人员需要比较详细的系统描述。需求工程有四个主要的阶段：1️⃣技术可行性研究2️⃣客户诉求导出和分析3️⃣需求文档化4️⃣需求有效性验证。

> 罗列你真正的需求，删除那些不必要的需求。写出实现需求的步骤，再删除不必要的步骤。继续重复上述两个步骤，看看这些步骤能不能加速，能不能自动化。—— Elon Musk

- Domain Driven Design

   DDD 是指你在软件中模拟如何在现实世界中解决问题，这部分现实世界就是业务领域，它包含多个业务上下文，每个上下文都有最适合自己的架构。

   DDD 的核心就是消化特定领域知识，并创建忠实反映它的软件模型。

[返回首页](#软件工程概述)

# 软件设计与实现

- 软件开发的实现阶段是把系统描述转换成一个可运行的系统的过程，它总是包含涉及和编程。这个过程描述了软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。设计者不可能一次就能完成一个完整的涉及，这是一个反复多次的过程。在设计过程中要不断添加设计要素和设计细节，并对先前的设计方案进行修正。软件设计因人而异，通常没有统一的模式。一些程序设计者从已经理解得很好的组件开始做起，然后再做不太熟悉的组件。其他人可能会采取相反的方案，把熟悉的组件留到最后，因为他们已经知道该如何开发这些组件。一些开发者喜欢先定义过程中要用到的数据，然后使用这些数据来驱动程序的开发。而另外一些人则是对数据现用现定义。设计过程一般包含：
  - [系统建模](#系统建模)
  - [结构设计](#结构设计)
  - [系统实现](#系统实现)

## 系统建模

- 我们一般通过系统建模来更好的理解需求文档。系统建模就是建立系统抽象模型的过程，每一个模型表示一个系统不同的角度或者方面。其包含1️⃣上下文模型：确定需求中较大颗粒度功能的数量和边界。2️⃣交互模型：有助于我们分析所提出的系统结构是否能实现需求文档所提及的功能及其可靠性。3️⃣结构模型：即系统体系结构设计，表示为组件构成的系统及组件之间的关系。4️⃣行为模型：描述系统运行时的动态行为。如数据输入，事件触发。

## 结构设计

> 软件架构中无时无刻地在表现组织结构。—— Melvin Conway(1967)

- 结构设计<font color="red">**识别系统的主要结构组件以及它们之间的关系**</font>，关心的是如何组织一个系统以及设计系统的整体结构。什么是好的结构？如何设计好的结构组件？我们需要好的<font color="red">**设计原则**</font>
  * （Simple Responsibility）单一职责：模块要尽量简单，并专注于一个核心任务
  * （Open Close）开闭原则：应当尽量保证模块对拓展开发，在后续使用中不可修改
  * （Liskov Substitution）里氏代换：好的继承：如果继承后的子类能够替换基类工作，那么这就是一个好的子类
  * （Interface Segregation）接口分离：好的接口：模块中尽量不应该存在无用的接口方法
  * （Dependency Inversion）依赖反转：鼓励面向接口编程：细节应当依赖于抽象，抽象不应当依赖于细节
- <font color="red">**如何处理复杂的依赖？我们需要实用的设计模式**</font>
  * （Service Locator Pattern）服务定位器：所有需要的服务都会被注册到服务定位器中，应用从服务定位器中得到服务。但是服务定位器的服务注册使代码更加复杂，当依赖有错误时只能在运行时发现。
  * （Inversion of Control）控制反转：通过配置将模块获取依赖这个过程，交给第三方生产工具。第三方生产工具通常称为IOC容器。

* <font color="red">**所有的软件在使用期间都需要维护**</font>，由此可见，好的软件必须确保自身可以有效重构。结构设计同时也要<font color="red">**处理好遗留代码**</font>。即使做好了最好准备，也不管团队的努力如何，系统的设计都可能在某个时刻陷入困境，最终大片代码开始变得难以维护和进化。管理者面临和魔鬼的交易，要么更多地修补和变通遗留代码，要么根据审核的需求和新的架构进行一次彻底的重新设计。就采取的措施而言修补和重新开发的区别是极小的，但在心理层面上重新开发则是管理层在承认失败。我们都很难愿意接受失败。下面是一些面向维护的好的建议：
  * 结构的可维护性取决于可读性、可测试性、可拓展性；
  * 面对运动损伤（无法修改的模块），医生会建议你停止运动（停止开发工作），在受伤的地方进行隔离和救治（代码隔离），当感觉良好的时候就开始尝试走动，如果感觉不舒服就停止（反复测试，持续重构）。
* 好的结构设计已经在不同的系统和环境中多次实践和测试过，<font color="red">**常见的设计实践包含**</font>：
  - 着重GUI流程的 Model View Controller 结构，常用于浏览器应用中；
  - 着重职责分明的 分层结构，User Interface layer，Business Logic Layer，Data access layer；
  - 着重数据共享的 容器结构，如提供依赖构建的 Inversion of Control 容器；

## 系统实现

- 软件设计和实现是软件工程过程中的一个阶段，在此阶段开发出可执行的软件系统。对简单系统来说，软件设计和实现就是软件工程的全部，其他所有活动都融汇在这个过程中。但是对于大型系统，软件设计和实现只是一系列软件工程过程中的一个。从很长的一段时间里首先，典型的开发方案差不多就是下面这样：首先，你收集需求，通过一些分析找出相关的业务实体，如用户、订单等；接着，带着这些理解，你尝试推导能够支撑流程的页面状态设计或是数据表设计，通常是关系型；接下来你组织页面交互或是编写接口，基于先前的状态/数据表设计来组织这些业务实体来完成业务流程，如用户登录，创建订单等；最后在表现层上，展现你的工作成果。

[返回首页](#软件工程概述)

# 软件有效性验证

* 软件有效性验证是要看系统是否符合它的描述以及系统是否满足客户的预期。这个过程通常称为测试过程，其中的阶段包括1️⃣单元测试：由开发系统的人员对组成系统的组件进行测试。组件可能是简单的实体，如一个函数或者对象类。2️⃣系统测试：集成组件形成完整的系统。这个过程主要是关注无法预测的组件间交互和组件界面问题引发的错误。也关注系统是否满足了功能上和非功能上的需求，并测试系统的总体特性。3️⃣接收测试：这是系统在接受并运行之前进行的最后阶段测试。这个阶段不再使用模拟数据来测试系统，而是用客户提供的真实数据测试系统。
* 统计学上表明一件事情，如果有可能，那么它一定会发生。在软件开发中，我们可以断言如果软件没经过测试，那么它一定会发生错误。

> 工程师都容易过度自信。但如果想要跑得快，就必须先要要跑的稳健。

[返回首页](#软件工程概述)

# 软件进化

* 软件进化是修改已存在的软件系统以适应用户新的需求的过程。变更是一个持续的过程，软件必须在变更过程中保持可用。

* 当我们的代码都处于高质量的状态时，日常工作几乎就是扩展和维护代码。这意味着使用设计原则设计好的结构，通过设计模式处理结构依赖，提升结构的维护性，掌握实用的设计实践是每个开发者都需要掌握的内容。但只要提及代码质量都会面临大量的生产力缺失以及成本控诉。生产力非常重要，但只关注生产力会导致更大成本，因为这会导致质量低下、难以维护的代码。无法修改的软件在变更需求后体现价值为零；但是目前无法工作的，但在未来可以持续修改的软件，会持续产生价值。

​		

[返回首页](#软件工程概述)

# 参考书籍

-   《Microsoft .NET 企业级应用架构设计（第二版）》
-   《软件工程》Ian Sommerville

[返回首页](#软件工程概述)
